###### Design Patterns Family

# Structural patterns
Structural patterns provide a manner to define relationships between classes or objects

## Adapter
[View code](https://github.com/joseivansandoya/patterns-in-javascript/blob/master/design-patterns/structural/adapter.js)

The addapter pattern is used when you need to wrap the functionality of existing classes (adaptee classes) that need to be used by other clients with incompatible interfaces. This is achieved by using a target interface (which is generated by the adapter class).
#### Key features
- The adaptee class can be an already defined class or can be a group of them
- The adapter class has to support an interface with the compatibility requirements that the client has. If it needs to wrap multiple classes, then it will have to implement interfaces for every adaptee case
- The client make use of the target interface (generated by the adapter class) instead of the adaptee ones.
#### When to use it?
- When it's necessary to provide a link between two otherwise incompatible types


## Decorator
[View code](https://github.com/joseivansandoya/patterns-in-javascript/blob/master/design-patterns/structural/decorator.js)

The decorator pattern is used to extend or alter the functionality of objects at run-time by wrapping them in an object of a decorator class. This provides a flexible alternative to using inheritance to modify behavior but without affecting nor the base class neither its already created instances.
#### Key features
- Decorator implements the interface of the extended (decorated) object transparently by forwarding all requests to it
- It perform additional functionality before/after forwarding a request
#### When to use it?
- When responsibilities should be added to (and removed from) an object dynamically at run-time
- When a flexible alternative to subclassing for extending functionality should be provided


## Facade
[View code](https://github.com/joseivansandoya/patterns-in-javascript/blob/master/design-patterns/structural/facade.js)

The decorator pattern is used to extend or alter the functionality of objects at run-time by wrapping them in an object of a decorator class. This provides a flexible alternative to using inheritance to modify behavior but without affecting nor the base class neither its already created instances.
#### Key features
- Decorator implements the interface of the extended (decorated) object transparently by forwarding all requests to it
- It perform additional functionality before/after forwarding a request
#### When to use it?
- When responsibilities should be added to (and removed from) an object dynamically at run-time
- When a flexible alternative to subclassing for extending functionality should be provided



### Structural patterns sumary
- **Adapter:** Converts one interface to another so that it matches what the client is expecting
- **Decorator:** Dynamically adds responsibility to the interface by wrapping the original code
- **Facade:** Provides a simplified interface
